import { measureViewportBox as n } from "../../projection/utils/measure.js";
import { DOMVisualElement as a } from "../dom/DOMVisualElement.js";
import { buildHTMLStyles as i } from "./utils/build-styles.js";
import { renderHTML as u } from "./utils/render.js";
import { scrapeMotionValuesFromProps as p } from "./utils/scrape-motion-values.js";
import { transformProps as l } from "../../../../../motion-dom/dist/es/render/utils/keys-transform.js";
import { defaultTransformValue as f, readTransformValue as c } from "../../../../../motion-dom/dist/es/render/dom/parse-transform.js";
import { isCSSVariableName as d } from "../../../../../motion-dom/dist/es/animation/utils/is-css-variable.js";
function V(m) {
  return window.getComputedStyle(m);
}
class b extends a {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = u;
  }
  readValueFromInstance(e, r) {
    var t;
    if (l.has(r))
      return (t = this.projection) != null && t.isProjecting ? f(r) : c(e, r);
    {
      const s = V(e), o = (d(r) ? s.getPropertyValue(r) : s[r]) || 0;
      return typeof o == "string" ? o.trim() : o;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: r }) {
    return n(e, r);
  }
  build(e, r, t) {
    i(e, r, t.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, r, t) {
    return p(e, r, t);
  }
}
export {
  b as HTMLVisualElement,
  V as getComputedStyle
};
