import { color as l } from "../color/index.js";
import { colorRegex as N } from "../utils/color-regex.js";
import { floatRegex as d } from "../utils/float-regex.js";
import { sanitize as x } from "../utils/sanitize.js";
function T(t) {
  var o, e;
  return isNaN(t) && typeof t == "string" && (((o = t.match(d)) == null ? void 0 : o.length) || 0) + (((e = t.match(N)) == null ? void 0 : e.length) || 0) > 0;
}
const a = "number", m = "color", b = "var", O = "var(", p = "${}", R = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function f(t) {
  const o = t.toString(), e = [], c = {
    color: [],
    number: [],
    var: []
  }, n = [];
  let s = 0;
  const u = o.replace(R, (i) => (l.test(i) ? (c.color.push(s), n.push(m), e.push(l.parse(i))) : i.startsWith(O) ? (c.var.push(s), n.push(b), e.push(i)) : (c.number.push(s), n.push(a), e.push(parseFloat(i))), ++s, p)).split(p);
  return { values: e, split: u, indexes: c, types: n };
}
function h(t) {
  return f(t).values;
}
function g(t) {
  const { split: o, types: e } = f(t), c = o.length;
  return (n) => {
    let s = "";
    for (let r = 0; r < c; r++)
      if (s += o[r], n[r] !== void 0) {
        const u = e[r];
        u === a ? s += x(n[r]) : u === m ? s += l.transform(n[r]) : s += n[r];
      }
    return s;
  };
}
const y = (t) => typeof t == "number" ? 0 : t;
function E(t) {
  const o = h(t);
  return g(t)(o.map(y));
}
const S = {
  test: T,
  parse: h,
  createTransformer: g,
  getAnimatableNone: E
};
export {
  f as analyseComplexValue,
  S as complex
};
