import { fillWildcards as y } from "./utils/fill-wildcards.js";
import { removeNonTranslationalTransform as p } from "./utils/unit-conversion.js";
import { frame as c } from "../../frameloop/frame.js";
const l = /* @__PURE__ */ new Set();
let o = !1, d = !1, m = !1;
function u() {
  if (d) {
    const r = Array.from(l).filter((e) => e.needsMeasurement), s = new Set(r.map((e) => e.element)), a = /* @__PURE__ */ new Map();
    s.forEach((e) => {
      const t = p(e);
      t.length && (a.set(e, t), e.render());
    }), r.forEach((e) => e.measureInitialState()), s.forEach((e) => {
      e.render();
      const t = a.get(e);
      t && t.forEach(([n, i]) => {
        var f;
        (f = e.getValue(n)) == null || f.set(i);
      });
    }), r.forEach((e) => e.measureEndState()), r.forEach((e) => {
      e.suspendedScrollY !== void 0 && window.scrollTo(0, e.suspendedScrollY);
    });
  }
  d = !1, o = !1, l.forEach((r) => r.complete(m)), l.clear();
}
function h() {
  l.forEach((r) => {
    r.readKeyframes(), r.needsMeasurement && (d = !0);
  });
}
function S() {
  m = !0, h(), u(), m = !1;
}
class g {
  constructor(s, a, e, t, n, i = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...s], this.onComplete = a, this.name = e, this.motionValue = t, this.element = n, this.isAsync = i;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (l.add(this), o || (o = !0, c.read(h), c.resolveKeyframes(u))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: s, name: a, element: e, motionValue: t } = this;
    if (s[0] === null) {
      const n = t == null ? void 0 : t.get(), i = s[s.length - 1];
      if (n !== void 0)
        s[0] = n;
      else if (e && a) {
        const f = e.readValue(a, i);
        f != null && (s[0] = f);
      }
      s[0] === void 0 && (s[0] = i), t && n === void 0 && t.set(s[0]);
    }
    y(s);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(s = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, s), l.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (l.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
export {
  g as KeyframeResolver,
  S as flushKeyframeResolvers
};
