import { animateMotionValue as L } from "../../animation/interfaces/motion-value.js";
import { addDomEvent as M } from "../../events/add-dom-event.js";
import { addPointerEvent as S } from "../../events/add-pointer-event.js";
import { extractEventInfo as B } from "../../events/event-info.js";
import { convertBoxToBoundingBox as k, convertBoundingBoxToBox as j } from "../../projection/geometry/conversion.js";
import { calcLength as T } from "../../projection/geometry/delta-calc.js";
import { createBox as w } from "../../projection/geometry/models.js";
import { eachAxis as u } from "../../projection/utils/each-axis.js";
import { measurePageBox as b } from "../../projection/utils/measure.js";
import { getContextWindow as R } from "../../utils/get-context-window.js";
import { isRefObject as D } from "../../utils/is-ref-object.js";
import { addValueToWillChange as V } from "../../value/use-will-change/add-will-change.js";
import { PanSession as W } from "../pan/PanSession.js";
import { applyConstraints as O, calcRelativeConstraints as U, resolveDragElastic as z, calcViewportConstraints as I, defaultElastic as _, rebaseAxisConstraints as F, calcOrigin as K } from "./utils/constraints.js";
import { frame as C } from "../../../../../motion-dom/dist/es/frameloop/frame.js";
import { invariant as N } from "../../../../../motion-utils/dist/es/errors.js";
import { setDragLock as $ } from "../../../../../motion-dom/dist/es/gestures/drag/state/set-active.js";
import { percent as q } from "../../../../../motion-dom/dist/es/value/types/numbers/units.js";
import { mixNumber as x } from "../../../../../motion-dom/dist/es/utils/mix/number.js";
const G = /* @__PURE__ */ new WeakMap();
class ft {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = w(), this.visualElement = t;
  }
  start(t, { snapToCursor: s = !1 } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && n.isPresent === !1)
      return;
    const i = (r) => {
      const { dragSnapToOrigin: a } = this.getProps();
      a ? this.pauseAnimation() : this.stopAnimation(), s && this.snapToCursor(B(r).point);
    }, o = (r, a) => {
      const { drag: f, dragPropagation: d, onDragStart: g } = this.getProps();
      if (f && !d && (this.openDragLock && this.openDragLock(), this.openDragLock = $(f), !this.openDragLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), u((m) => {
        let E = this.getAxisMotionValue(m).get() || 0;
        if (q.test(E)) {
          const { projection: A } = this.visualElement;
          if (A && A.layout) {
            const y = A.layout.layoutBox[m];
            y && (E = T(y) * (parseFloat(E) / 100));
          }
        }
        this.originPoint[m] = E;
      }), g && C.postRender(() => g(r, a)), V(this.visualElement, "transform");
      const { animationState: v } = this.visualElement;
      v && v.setActive("whileDrag", !0);
    }, e = (r, a) => {
      const { dragPropagation: f, dragDirectionLock: d, onDirectionLock: g, onDrag: v } = this.getProps();
      if (!f && !this.openDragLock)
        return;
      const { offset: m } = a;
      if (d && this.currentDirection === null) {
        this.currentDirection = H(m), this.currentDirection !== null && g && g(this.currentDirection);
        return;
      }
      this.updateAxis("x", a.point, m), this.updateAxis("y", a.point, m), this.visualElement.render(), v && v(r, a);
    }, l = (r, a) => this.stop(r, a), c = () => u((r) => {
      var a;
      return this.getAnimationState(r) === "paused" && ((a = this.getAxisMotionValue(r).animation) == null ? void 0 : a.play());
    }), { dragSnapToOrigin: h } = this.getProps();
    this.panSession = new W(t, {
      onSessionStart: i,
      onStart: o,
      onMove: e,
      onSessionEnd: l,
      resumeAnimation: c
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: h,
      contextWindow: R(this.visualElement)
    });
  }
  stop(t, s) {
    const n = this.isDragging;
    if (this.cancel(), !n)
      return;
    const { velocity: i } = s;
    this.startAnimation(i);
    const { onDragEnd: o } = this.getProps();
    o && C.postRender(() => o(t, s));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: s } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: n } = this.getProps();
    !n && this.openDragLock && (this.openDragLock(), this.openDragLock = null), s && s.setActive("whileDrag", !1);
  }
  updateAxis(t, s, n) {
    const { drag: i } = this.getProps();
    if (!n || !P(t, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(t);
    let e = this.originPoint[t] + n[t];
    this.constraints && this.constraints[t] && (e = O(e, this.constraints[t], this.elastic[t])), o.set(e);
  }
  resolveConstraints() {
    var o;
    const { dragConstraints: t, dragElastic: s } = this.getProps(), n = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (o = this.visualElement.projection) == null ? void 0 : o.layout, i = this.constraints;
    t && D(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && n ? this.constraints = U(n.layoutBox, t) : this.constraints = !1, this.elastic = z(s), i !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && u((e) => {
      this.constraints !== !1 && this.getAxisMotionValue(e) && (this.constraints[e] = F(n.layoutBox[e], this.constraints[e]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: s } = this.getProps();
    if (!t || !D(t))
      return !1;
    const n = t.current;
    N(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = b(n, i.root, this.visualElement.getTransformPagePoint());
    let e = I(i.layout.layoutBox, o);
    if (s) {
      const l = s(k(e));
      this.hasMutatedConstraints = !!l, l && (e = j(l));
    }
    return e;
  }
  startAnimation(t) {
    const { drag: s, dragMomentum: n, dragElastic: i, dragTransition: o, dragSnapToOrigin: e, onDragTransitionEnd: l } = this.getProps(), c = this.constraints || {}, h = u((r) => {
      if (!P(r, s, this.currentDirection))
        return;
      let a = c && c[r] || {};
      e && (a = { min: 0, max: 0 });
      const f = i ? 200 : 1e6, d = i ? 40 : 1e7, g = {
        type: "inertia",
        velocity: n ? t[r] : 0,
        bounceStiffness: f,
        bounceDamping: d,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...a
      };
      return this.startAxisValueAnimation(r, g);
    });
    return Promise.all(h).then(l);
  }
  startAxisValueAnimation(t, s) {
    const n = this.getAxisMotionValue(t);
    return V(this.visualElement, t), n.start(L(t, n, 0, s, this.visualElement, !1));
  }
  stopAnimation() {
    u((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    u((t) => {
      var s;
      return (s = this.getAxisMotionValue(t).animation) == null ? void 0 : s.pause();
    });
  }
  getAnimationState(t) {
    var s;
    return (s = this.getAxisMotionValue(t).animation) == null ? void 0 : s.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const s = `_drag${t.toUpperCase()}`, n = this.visualElement.getProps(), i = n[s];
    return i || this.visualElement.getValue(t, (n.initial ? n.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    u((s) => {
      const { drag: n } = this.getProps();
      if (!P(s, n, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(s);
      if (i && i.layout) {
        const { min: e, max: l } = i.layout.layoutBox[s];
        o.set(t[s] - x(e, l, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: s } = this.getProps(), { projection: n } = this.visualElement;
    if (!D(s) || !n || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    u((e) => {
      const l = this.getAxisMotionValue(e);
      if (l && this.constraints !== !1) {
        const c = l.get();
        i[e] = K({ min: c, max: c }, this.constraints[e]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), u((e) => {
      if (!P(e, t, null))
        return;
      const l = this.getAxisMotionValue(e), { min: c, max: h } = this.constraints[e];
      l.set(x(c, h, i[e]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    G.set(this.visualElement, this);
    const t = this.visualElement.current, s = S(t, "pointerdown", (c) => {
      const { drag: h, dragListener: r = !0 } = this.getProps();
      h && r && this.start(c);
    }), n = () => {
      const { dragConstraints: c } = this.getProps();
      D(c) && c.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, o = i.addEventListener("measure", n);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), C.read(n);
    const e = M(window, "resize", () => this.scalePositionWithinConstraints()), l = i.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: h }) => {
      this.isDragging && h && (u((r) => {
        const a = this.getAxisMotionValue(r);
        a && (this.originPoint[r] += c[r].translate, a.set(a.get() + c[r].translate));
      }), this.visualElement.render());
    });
    return () => {
      e(), s(), o(), l && l();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: s = !1, dragDirectionLock: n = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: e = _, dragMomentum: l = !0 } = t;
    return {
      ...t,
      drag: s,
      dragDirectionLock: n,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: e,
      dragMomentum: l
    };
  }
}
function P(p, t, s) {
  return (t === !0 || t === p) && (s === null || s === p);
}
function H(p, t = 10) {
  let s = null;
  return Math.abs(p.y) > t ? s = "y" : Math.abs(p.x) > t && (s = "x"), s;
}
export {
  ft as VisualElementDragControls,
  G as elementDragControls
};
