import { time as v } from "../frameloop/sync-time.js";
import { JSAnimation as y } from "./JSAnimation.js";
import { getFinalKeyframe as R } from "./keyframes/get-final.js";
import { KeyframeResolver as g, flushKeyframeResolvers as T } from "./keyframes/KeyframesResolver.js";
import { NativeAnimationExtended as _ } from "./NativeAnimationExtended.js";
import { canAnimate as w } from "./utils/can-animate.js";
import { WithPromise as K } from "./utils/WithPromise.js";
import { supportsBrowserAnimation as E } from "./waapi/supports/waapi.js";
import { MotionGlobalConfig as x } from "../../../../motion-utils/dist/es/global-config.js";
import { noop as M } from "../../../../motion-utils/dist/es/noop.js";
const k = 40;
class G extends K {
  constructor({ autoplay: i = !0, delay: s = 0, type: e = "keyframes", repeat: l = 0, repeatDelay: f = 0, repeatType: d = "loop", keyframes: c, name: a, motionValue: r, element: t, ...p }) {
    var u;
    super(), this.stop = () => {
      var m, h;
      this._animation && (this._animation.stop(), (m = this.stopTimeline) == null || m.call(this)), (h = this.keyframeResolver) == null || h.cancel();
    }, this.createdAt = v.now();
    const n = {
      autoplay: i,
      delay: s,
      type: e,
      repeat: l,
      repeatDelay: f,
      repeatType: d,
      name: a,
      motionValue: r,
      element: t,
      ...p
    }, o = (t == null ? void 0 : t.KeyframeResolver) || g;
    this.keyframeResolver = new o(c, (m, h, A) => this.onKeyframesResolved(m, h, n, !A), a, r, t), (u = this.keyframeResolver) == null || u.scheduleResolve();
  }
  onKeyframesResolved(i, s, e, l) {
    this.keyframeResolver = void 0;
    const { name: f, type: d, velocity: c, delay: a, isHandoff: r, onUpdate: t } = e;
    this.resolvedAt = v.now(), w(i, f, d, c) || ((x.instantAnimations || !a) && (t == null || t(R(i, e, s))), i[0] = i[i.length - 1], e.duration = 0, e.repeat = 0);
    const n = {
      startTime: l ? this.resolvedAt ? this.resolvedAt - this.createdAt > k ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: s,
      ...e,
      keyframes: i
    }, o = !r && E(n) ? new _({
      ...n,
      element: n.motionValue.owner.current
    }) : new y(n);
    o.finished.then(() => this.notifyFinished()).catch(M), this.pendingTimeline && (this.stopTimeline = o.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = o;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(i, s) {
    return this.finished.finally(i).then(() => {
    });
  }
  get animation() {
    var i;
    return this._animation || ((i = this.keyframeResolver) == null || i.resume(), T()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(i) {
    this.animation.time = i;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(i) {
    this.animation.speed = i;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(i) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(i) : this.pendingTimeline = i, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var i;
    this._animation && this.animation.cancel(), (i = this.keyframeResolver) == null || i.cancel();
  }
}
export {
  G as AsyncMotionValueAnimation
};
