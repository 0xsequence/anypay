import { animateSingleValue as ot } from "../../animation/animate/single-value.js";
import { getOptimisedAppearId as at } from "../../animation/optimized-appear/get-appear-id.js";
import { FlatTree as rt } from "../../render/utils/flat-tree.js";
import { delay as nt } from "../../utils/delay.js";
import { resolveMotionValue as w } from "../../value/utils/resolve-motion-value.js";
import { mixValues as lt } from "../animation/mix-values.js";
import { copyBoxInto as y, copyAxisDeltaInto as M } from "../geometry/copy.js";
import { translateAxis as k, transformBox as L, applyBoxDelta as ht, applyTreeDeltas as ut } from "../geometry/delta-apply.js";
import { calcLength as P, calcRelativePosition as R, calcRelativeBox as ct, calcBoxDelta as V, isNear as dt } from "../geometry/delta-calc.js";
import { removeBoxTransforms as b } from "../geometry/delta-remove.js";
import { createBox as d, createDelta as B } from "../geometry/models.js";
import { boxEqualsRounded as _, isDeltaZero as tt, axisDeltaEquals as z, boxEquals as mt, aspectRatio as N } from "../geometry/utils.js";
import { NodeStack as ft } from "../shared/stack.js";
import { scaleCorrectors as W } from "../styles/scale-correction.js";
import { buildProjectionTransform as pt } from "../styles/transform.js";
import { eachAxis as H } from "../utils/each-axis.js";
import { hasTransform as S, hasScale as G, has2DTranslate as yt } from "../utils/has-transform.js";
import { globalProjectionState as C } from "./state.js";
import { SubscriptionManager as gt } from "../../../../../motion-utils/dist/es/subscription-manager.js";
import { isSVGElement as Tt } from "../../../../../motion-dom/dist/es/utils/is-svg-element.js";
import { isSVGSVGElement as vt } from "../../../../../motion-dom/dist/es/utils/is-svg-svg-element.js";
import { getValueTransition as xt } from "../../../../../motion-dom/dist/es/animation/utils/get-value-transition.js";
import { cancelFrame as q, frameData as g, frameSteps as O, frame as E } from "../../../../../motion-dom/dist/es/frameloop/frame.js";
import { time as Dt } from "../../../../../motion-dom/dist/es/frameloop/sync-time.js";
import { clamp as St } from "../../../../../motion-utils/dist/es/clamp.js";
import { microtask as Pt } from "../../../../../motion-dom/dist/es/frameloop/microtask.js";
import { motionValue as Bt } from "../../../../../motion-dom/dist/es/value/index.js";
import { mixNumber as U } from "../../../../../motion-dom/dist/es/utils/mix/number.js";
import { noop as jt } from "../../../../../motion-utils/dist/es/noop.js";
const F = ["", "X", "Y", "Z"], At = { visibility: "hidden" }, Rt = 1e3;
let Vt = 0;
function I(i, n, c, u) {
  const { latestValues: T } = n;
  T[i] && (c[i] = T[i], n.setStaticValue(i, 0), u && (u[i] = 0));
}
function et(i) {
  if (i.hasCheckedOptimisedAppear = !0, i.root === i)
    return;
  const { visualElement: n } = i.options;
  if (!n)
    return;
  const c = at(n);
  if (window.MotionHasOptimisedAnimation(c, "transform")) {
    const { layout: T, layoutId: j } = i.options;
    window.MotionCancelOptimisedAnimation(c, "transform", E, !(T || j));
  }
  const { parent: u } = i;
  u && !u.hasCheckedOptimisedAppear && et(u);
}
function De({ attachResizeListener: i, defaultParent: n, measureScroll: c, checkIsScrollRoot: u, resetTransform: T }) {
  return class {
    constructor(t = {}, e = n == null ? void 0 : n()) {
      this.id = Vt++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(Et), this.nodes.forEach(Ft), this.nodes.forEach(It), this.nodes.forEach(Ut);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = t, this.root = e ? e.root || e : this, this.path = e ? [...e.path, e] : [], this.parent = e, this.depth = e ? e.depth + 1 : 0;
      for (let s = 0; s < this.path.length; s++)
        this.path[s].shouldResetTransform = !0;
      this.root === this && (this.nodes = new rt());
    }
    addEventListener(t, e) {
      return this.eventHandlers.has(t) || this.eventHandlers.set(t, new gt()), this.eventHandlers.get(t).add(e);
    }
    notifyListeners(t, ...e) {
      const s = this.eventHandlers.get(t);
      s && s.notify(...e);
    }
    hasListeners(t) {
      return this.eventHandlers.has(t);
    }
    /**
     * Lifecycles
     */
    mount(t) {
      if (this.instance)
        return;
      this.isSVG = Tt(t) && !vt(t), this.instance = t;
      const { layoutId: e, layout: s, visualElement: o } = this.options;
      if (o && !o.current && o.mount(t), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (s || e) && (this.isLayoutDirty = !0), i) {
        let a;
        const r = () => this.root.updateBlockedByResize = !1;
        i(t, () => {
          this.root.updateBlockedByResize = !0, a && a(), a = nt(r, 250), C.hasAnimatedSinceResize && (C.hasAnimatedSinceResize = !1, this.nodes.forEach(Y));
        });
      }
      e && this.root.registerSharedNode(e, this), this.options.animate !== !1 && o && (e || s) && this.addEventListener("didUpdate", ({ delta: a, hasLayoutChanged: r, hasRelativeLayoutChanged: h, layout: l }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const f = this.options.transition || o.getDefaultTransition() || Wt, { onLayoutAnimationStart: p, onLayoutAnimationComplete: x } = o.getProps(), v = !this.targetLayout || !_(this.targetLayout, l), D = !r && h;
        if (this.options.layoutRoot || this.resumeFrom || D || r && (v || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const m = {
            ...xt(f, "layout"),
            onPlay: p,
            onComplete: x
          };
          (o.shouldReduceMotion || this.options.layoutRoot) && (m.delay = 0, m.type = !1), this.startAnimation(m), this.setAnimationOrigin(a, D);
        } else
          r || Y(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = l;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const t = this.getStack();
      t && t.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), q(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Mt), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: t } = this.options;
      return t && t.getProps().transformTemplate;
    }
    willUpdate(t = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && et(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let a = 0; a < this.path.length; a++) {
        const r = this.path[a];
        r.shouldResetTransform = !0, r.updateScroll("snapshot"), r.options.layoutRoot && r.willUpdate(!1);
      }
      const { layoutId: e, layout: s } = this.options;
      if (e === void 0 && !s)
        return;
      const o = this.getTransformTemplate();
      this.prevTransformTemplateValue = o ? o(this.latestValues, "") : void 0, this.updateSnapshot(), t && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(X);
        return;
      }
      this.isUpdating || this.nodes.forEach(Ct), this.isUpdating = !1, this.nodes.forEach(Ot), this.nodes.forEach(kt), this.nodes.forEach(Lt), this.clearAllSnapshots();
      const e = Dt.now();
      g.delta = St(0, 1e3 / 60, e - g.timestamp), g.timestamp = e, g.isProcessing = !0, O.update.process(g), O.preRender.process(g), O.render.process(g), g.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Pt.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(wt), this.sharedNodes.forEach(bt);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, E.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      E.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !P(this.snapshot.measuredBox.x) && !P(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let s = 0; s < this.path.length; s++)
          this.path[s].updateScroll();
      const t = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = d(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: e } = this.options;
      e && e.notify("LayoutMeasure", this.layout.layoutBox, t ? t.layoutBox : void 0);
    }
    updateScroll(t = "measure") {
      let e = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (e = !1), e && this.instance) {
        const s = u(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: t,
          isRoot: s,
          offset: c(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : s
        };
      }
    }
    resetTransform() {
      if (!T)
        return;
      const t = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, e = this.projectionDelta && !tt(this.projectionDelta), s = this.getTransformTemplate(), o = s ? s(this.latestValues, "") : void 0, a = o !== this.prevTransformTemplateValue;
      t && this.instance && (e || S(this.latestValues) || a) && (T(this.instance, o), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(t = !0) {
      const e = this.measurePageBox();
      let s = this.removeElementScroll(e);
      return t && (s = this.removeTransform(s)), Ht(s), {
        animationId: this.root.animationId,
        measuredBox: e,
        layoutBox: s,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: t } = this.options;
      if (!t)
        return d();
      const e = t.measureViewportBox();
      if (!(((o = this.scroll) == null ? void 0 : o.wasRoot) || this.path.some(Gt))) {
        const { scroll: a } = this.root;
        a && (k(e.x, a.offset.x), k(e.y, a.offset.y));
      }
      return e;
    }
    removeElementScroll(t) {
      var s;
      const e = d();
      if (y(e, t), (s = this.scroll) != null && s.wasRoot)
        return e;
      for (let o = 0; o < this.path.length; o++) {
        const a = this.path[o], { scroll: r, options: h } = a;
        a !== this.root && r && h.layoutScroll && (r.wasRoot && y(e, t), k(e.x, r.offset.x), k(e.y, r.offset.y));
      }
      return e;
    }
    applyTransform(t, e = !1) {
      const s = d();
      y(s, t);
      for (let o = 0; o < this.path.length; o++) {
        const a = this.path[o];
        !e && a.options.layoutScroll && a.scroll && a !== a.root && L(s, {
          x: -a.scroll.offset.x,
          y: -a.scroll.offset.y
        }), S(a.latestValues) && L(s, a.latestValues);
      }
      return S(this.latestValues) && L(s, this.latestValues), s;
    }
    removeTransform(t) {
      const e = d();
      y(e, t);
      for (let s = 0; s < this.path.length; s++) {
        const o = this.path[s];
        if (!o.instance || !S(o.latestValues))
          continue;
        G(o.latestValues) && o.updateSnapshot();
        const a = d(), r = o.measurePageBox();
        y(a, r), b(e, o.latestValues, o.snapshot ? o.snapshot.layoutBox : void 0, a);
      }
      return S(this.latestValues) && b(e, this.latestValues), e;
    }
    setTargetDelta(t) {
      this.targetDelta = t, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(t) {
      this.options = {
        ...this.options,
        ...t,
        crossfade: t.crossfade !== void 0 ? t.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== g.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(t = !1) {
      var h;
      const e = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = e.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = e.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = e.isSharedProjectionDirty);
      const s = !!this.resumingFrom || this !== e;
      if (!(t || s && this.isSharedProjectionDirty || this.isProjectionDirty || (h = this.parent) != null && h.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: a, layoutId: r } = this.options;
      if (!(!this.layout || !(a || r))) {
        if (this.resolvedRelativeTargetAt = g.timestamp, !this.targetDelta && !this.relativeTarget) {
          const l = this.getClosestProjectingParent();
          l && l.layout && this.animationProgress !== 1 ? (this.relativeParent = l, this.forceRelativeParentToResolveTarget(), this.relativeTarget = d(), this.relativeTargetOrigin = d(), R(this.relativeTargetOrigin, this.layout.layoutBox, l.layout.layoutBox), y(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = d(), this.targetWithTransforms = d()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), ct(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : y(this.target, this.layout.layoutBox), ht(this.target, this.targetDelta)) : y(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const l = this.getClosestProjectingParent();
          l && !!l.resumingFrom == !!this.resumingFrom && !l.options.layoutScroll && l.target && this.animationProgress !== 1 ? (this.relativeParent = l, this.forceRelativeParentToResolveTarget(), this.relativeTarget = d(), this.relativeTargetOrigin = d(), R(this.relativeTargetOrigin, this.target, l.target), y(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || G(this.parent.latestValues) || yt(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var f;
      const t = this.getLead(), e = !!this.resumingFrom || this !== t;
      let s = !0;
      if ((this.isProjectionDirty || (f = this.parent) != null && f.isProjectionDirty) && (s = !1), e && (this.isSharedProjectionDirty || this.isTransformDirty) && (s = !1), this.resolvedRelativeTargetAt === g.timestamp && (s = !1), s)
        return;
      const { layout: o, layoutId: a } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(o || a))
        return;
      y(this.layoutCorrected, this.layout.layoutBox);
      const r = this.treeScale.x, h = this.treeScale.y;
      ut(this.layoutCorrected, this.treeScale, this.path, e), t.layout && !t.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (t.target = t.layout.layoutBox, t.targetWithTransforms = d());
      const { target: l } = t;
      if (!l) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (M(this.prevProjectionDelta.x, this.projectionDelta.x), M(this.prevProjectionDelta.y, this.projectionDelta.y)), V(this.projectionDelta, this.layoutCorrected, l, this.latestValues), (this.treeScale.x !== r || this.treeScale.y !== h || !z(this.projectionDelta.x, this.prevProjectionDelta.x) || !z(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", l));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(t = !0) {
      var e;
      if ((e = this.options.visualElement) == null || e.scheduleRender(), t) {
        const s = this.getStack();
        s && s.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = B(), this.projectionDelta = B(), this.projectionDeltaWithTransform = B();
    }
    setAnimationOrigin(t, e = !1) {
      const s = this.snapshot, o = s ? s.latestValues : {}, a = { ...this.latestValues }, r = B();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e;
      const h = d(), l = s ? s.source : void 0, f = this.layout ? this.layout.source : void 0, p = l !== f, x = this.getStack(), v = !x || x.members.length <= 1, D = !!(p && !v && this.options.crossfade === !0 && !this.path.some(Nt));
      this.animationProgress = 0;
      let m;
      this.mixTargetDelta = (st) => {
        const A = st / 1e3;
        $(r.x, t.x, A), $(r.y, t.y, A), this.setTargetDelta(r), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (R(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox), zt(this.relativeTarget, this.relativeTargetOrigin, h, A), m && mt(this.relativeTarget, m) && (this.isProjectionDirty = !1), m || (m = d()), y(m, this.relativeTarget)), p && (this.animationValues = a, lt(a, o, this.latestValues, A, D, v)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = A;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(t) {
      var e, s, o;
      this.notifyListeners("animationStart"), (e = this.currentAnimation) == null || e.stop(), (o = (s = this.resumingFrom) == null ? void 0 : s.currentAnimation) == null || o.stop(), this.pendingAnimation && (q(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = E.update(() => {
        C.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Bt(0)), this.currentAnimation = ot(this.motionValue, [0, 1e3], {
          ...t,
          velocity: 0,
          isSync: !0,
          onUpdate: (a) => {
            this.mixTargetDelta(a), t.onUpdate && t.onUpdate(a);
          },
          onStop: () => {
          },
          onComplete: () => {
            t.onComplete && t.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const t = this.getStack();
      t && t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Rt), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const t = this.getLead();
      let { targetWithTransforms: e, target: s, layout: o, latestValues: a } = t;
      if (!(!e || !s || !o)) {
        if (this !== t && this.layout && o && it(this.options.animationType, this.layout.layoutBox, o.layoutBox)) {
          s = this.target || d();
          const r = P(this.layout.layoutBox.x);
          s.x.min = t.target.x.min, s.x.max = s.x.min + r;
          const h = P(this.layout.layoutBox.y);
          s.y.min = t.target.y.min, s.y.max = s.y.min + h;
        }
        y(e, s), L(e, a), V(this.projectionDeltaWithTransform, this.layoutCorrected, e, a);
      }
    }
    registerSharedNode(t, e) {
      this.sharedNodes.has(t) || this.sharedNodes.set(t, new ft()), this.sharedNodes.get(t).add(e);
      const o = e.options.initialPromotionConfig;
      e.promote({
        transition: o ? o.transition : void 0,
        preserveFollowOpacity: o && o.shouldPreserveFollowOpacity ? o.shouldPreserveFollowOpacity(e) : void 0
      });
    }
    isLead() {
      const t = this.getStack();
      return t ? t.lead === this : !0;
    }
    getLead() {
      var e;
      const { layoutId: t } = this.options;
      return t ? ((e = this.getStack()) == null ? void 0 : e.lead) || this : this;
    }
    getPrevLead() {
      var e;
      const { layoutId: t } = this.options;
      return t ? (e = this.getStack()) == null ? void 0 : e.prevLead : void 0;
    }
    getStack() {
      const { layoutId: t } = this.options;
      if (t)
        return this.root.sharedNodes.get(t);
    }
    promote({ needsReset: t, transition: e, preserveFollowOpacity: s } = {}) {
      const o = this.getStack();
      o && o.promote(this, s), t && (this.projectionDelta = void 0, this.needsReset = !0), e && this.setOptions({ transition: e });
    }
    relegate() {
      const t = this.getStack();
      return t ? t.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: t } = this.options;
      if (!t)
        return;
      let e = !1;
      const { latestValues: s } = t;
      if ((s.z || s.rotate || s.rotateX || s.rotateY || s.rotateZ || s.skewX || s.skewY) && (e = !0), !e)
        return;
      const o = {};
      s.z && I("z", t, o, this.animationValues);
      for (let a = 0; a < F.length; a++)
        I(`rotate${F[a]}`, t, o, this.animationValues), I(`skew${F[a]}`, t, o, this.animationValues);
      t.render();
      for (const a in o)
        t.setStaticValue(a, o[a]), this.animationValues && (this.animationValues[a] = o[a]);
      t.scheduleRender();
    }
    getProjectionStyles(t) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return At;
      const e = {
        visibility: ""
      }, s = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, e.opacity = "", e.pointerEvents = w(t == null ? void 0 : t.pointerEvents) || "", e.transform = s ? s(this.latestValues, "") : "none", e;
      const o = this.getLead();
      if (!this.projectionDelta || !this.layout || !o.target) {
        const l = {};
        return this.options.layoutId && (l.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, l.pointerEvents = w(t == null ? void 0 : t.pointerEvents) || ""), this.hasProjected && !S(this.latestValues) && (l.transform = s ? s({}, "") : "none", this.hasProjected = !1), l;
      }
      const a = o.animationValues || o.latestValues;
      this.applyTransformsToTarget(), e.transform = pt(this.projectionDeltaWithTransform, this.treeScale, a), s && (e.transform = s(a, e.transform));
      const { x: r, y: h } = this.projectionDelta;
      e.transformOrigin = `${r.origin * 100}% ${h.origin * 100}% 0`, o.animationValues ? e.opacity = o === this ? a.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : a.opacityExit : e.opacity = o === this ? a.opacity !== void 0 ? a.opacity : "" : a.opacityExit !== void 0 ? a.opacityExit : 0;
      for (const l in W) {
        if (a[l] === void 0)
          continue;
        const { correct: f, applyTo: p, isCSSVariable: x } = W[l], v = e.transform === "none" ? a[l] : f(a[l], o);
        if (p) {
          const D = p.length;
          for (let m = 0; m < D; m++)
            e[p[m]] = v;
        } else
          x ? this.options.visualElement.renderState.vars[l] = v : e[l] = v;
      }
      return this.options.layoutId && (e.pointerEvents = o === this ? w(t == null ? void 0 : t.pointerEvents) || "" : "none"), e;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((t) => {
        var e;
        return (e = t.currentAnimation) == null ? void 0 : e.stop();
      }), this.root.nodes.forEach(X), this.root.sharedNodes.clear();
    }
  };
}
function kt(i) {
  i.updateLayout();
}
function Lt(i) {
  var c;
  const n = ((c = i.resumeFrom) == null ? void 0 : c.snapshot) || i.snapshot;
  if (i.isLead() && i.layout && n && i.hasListeners("didUpdate")) {
    const { layoutBox: u, measuredBox: T } = i.layout, { animationType: j } = i.options, t = n.source !== i.layout.source;
    j === "size" ? H((r) => {
      const h = t ? n.measuredBox[r] : n.layoutBox[r], l = P(h);
      h.min = u[r].min, h.max = h.min + l;
    }) : it(j, n.layoutBox, u) && H((r) => {
      const h = t ? n.measuredBox[r] : n.layoutBox[r], l = P(u[r]);
      h.max = h.min + l, i.relativeTarget && !i.currentAnimation && (i.isProjectionDirty = !0, i.relativeTarget[r].max = i.relativeTarget[r].min + l);
    });
    const e = B();
    V(e, u, n.layoutBox);
    const s = B();
    t ? V(s, i.applyTransform(T, !0), n.measuredBox) : V(s, u, n.layoutBox);
    const o = !tt(e);
    let a = !1;
    if (!i.resumeFrom) {
      const r = i.getClosestProjectingParent();
      if (r && !r.resumeFrom) {
        const { snapshot: h, layout: l } = r;
        if (h && l) {
          const f = d();
          R(f, n.layoutBox, h.layoutBox);
          const p = d();
          R(p, u, l.layoutBox), _(f, p) || (a = !0), r.options.layoutRoot && (i.relativeTarget = p, i.relativeTargetOrigin = f, i.relativeParent = r);
        }
      }
    }
    i.notifyListeners("didUpdate", {
      layout: u,
      snapshot: n,
      delta: s,
      layoutDelta: e,
      hasLayoutChanged: o,
      hasRelativeLayoutChanged: a
    });
  } else if (i.isLead()) {
    const { onExitComplete: u } = i.options;
    u && u();
  }
  i.options.transition = void 0;
}
function Et(i) {
  i.parent && (i.isProjecting() || (i.isProjectionDirty = i.parent.isProjectionDirty), i.isSharedProjectionDirty || (i.isSharedProjectionDirty = !!(i.isProjectionDirty || i.parent.isProjectionDirty || i.parent.isSharedProjectionDirty)), i.isTransformDirty || (i.isTransformDirty = i.parent.isTransformDirty));
}
function Ut(i) {
  i.isProjectionDirty = i.isSharedProjectionDirty = i.isTransformDirty = !1;
}
function wt(i) {
  i.clearSnapshot();
}
function X(i) {
  i.clearMeasurements();
}
function Ct(i) {
  i.isLayoutDirty = !1;
}
function Ot(i) {
  const { visualElement: n } = i.options;
  n && n.getProps().onBeforeLayoutMeasure && n.notify("BeforeLayoutMeasure"), i.resetTransform();
}
function Y(i) {
  i.finishAnimation(), i.targetDelta = i.relativeTarget = i.target = void 0, i.isProjectionDirty = !0;
}
function Ft(i) {
  i.resolveTargetDelta();
}
function It(i) {
  i.calcProjection();
}
function Mt(i) {
  i.resetSkewAndRotation();
}
function bt(i) {
  i.removeLeadSnapshot();
}
function $(i, n, c) {
  i.translate = U(n.translate, 0, c), i.scale = U(n.scale, 1, c), i.origin = n.origin, i.originPoint = n.originPoint;
}
function Z(i, n, c, u) {
  i.min = U(n.min, c.min, u), i.max = U(n.max, c.max, u);
}
function zt(i, n, c, u) {
  Z(i.x, n.x, c.x, u), Z(i.y, n.y, c.y, u);
}
function Nt(i) {
  return i.animationValues && i.animationValues.opacityExit !== void 0;
}
const Wt = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, J = (i) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(i), K = J("applewebkit/") && !J("chrome/") ? Math.round : jt;
function Q(i) {
  i.min = K(i.min), i.max = K(i.max);
}
function Ht(i) {
  Q(i.x), Q(i.y);
}
function it(i, n, c) {
  return i === "position" || i === "preserve-aspect" && !dt(N(n), N(c), 0.2);
}
function Gt(i) {
  var n;
  return i !== i.root && ((n = i.scroll) == null ? void 0 : n.wasRoot);
}
export {
  Ut as cleanDirtyNodes,
  De as createProjectionNode,
  Z as mixAxis,
  $ as mixAxisDelta,
  zt as mixBox,
  Et as propagateDirtyNodes
};
