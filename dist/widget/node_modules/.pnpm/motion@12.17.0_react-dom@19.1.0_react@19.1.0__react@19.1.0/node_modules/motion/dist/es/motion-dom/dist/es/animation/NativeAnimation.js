import { setStyle as p } from "../render/dom/style-set.js";
import { supportsScrollTimeline as f } from "../utils/supports/scroll-timeline.js";
import { getFinalKeyframe as u } from "./keyframes/get-final.js";
import { WithPromise as d } from "./utils/WithPromise.js";
import { startWaapiAnimation as c } from "./waapi/start-waapi-animation.js";
import { applyGeneratorOptions as y } from "./waapi/utils/apply-generator.js";
import { invariant as T } from "../../../../motion-utils/dist/es/errors.js";
import { millisecondsToSeconds as r, secondsToMilliseconds as g } from "../../../../motion-utils/dist/es/time-conversion.js";
import { noop as S } from "../../../../motion-utils/dist/es/noop.js";
class x extends d {
  constructor(i) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !i)
      return;
    const { element: t, name: e, keyframes: a, pseudoElement: n, allowFlatten: h = !1, finalKeyframe: l, onComplete: s } = i;
    this.isPseudoElement = !!n, this.allowFlatten = h, this.options = i, T(typeof i.type != "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "motion"?`);
    const o = y(i);
    this.animation = c(t, e, a, o, n), o.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !n) {
        const m = u(a, this.options, l, this.speed);
        this.updateMotionValue ? this.updateMotionValue(m) : p(t, e, m), this.animation.cancel();
      }
      s == null || s(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var i, t;
    (t = (i = this.animation).finish) == null || t.call(i);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: i } = this;
    i === "idle" || i === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var i, t;
    this.isPseudoElement || (t = (i = this.animation).commitStyles) == null || t.call(i);
  }
  get duration() {
    var t, e;
    const i = ((e = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : e.call(t).duration) || 0;
    return r(Number(i));
  }
  get time() {
    return r(Number(this.animation.currentTime) || 0);
  }
  set time(i) {
    this.finishedTime = null, this.animation.currentTime = g(i);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(i) {
    i < 0 && (this.finishedTime = null), this.animation.playbackRate = i;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(i) {
    this.animation.startTime = i;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: i, observe: t }) {
    var e;
    return this.allowFlatten && ((e = this.animation.effect) == null || e.updateTiming({ easing: "linear" })), this.animation.onfinish = null, i && f() ? (this.animation.timeline = i, S) : t(this);
  }
}
export {
  x as NativeAnimation
};
