import { useContext as f, useRef as l, useInsertionEffect as j, useEffect as I } from "react";
import { optimizedAppearDataAttribute as h } from "../../animation/optimized-appear/data-id.js";
import { LazyContext as A } from "../../context/LazyContext.js";
import { MotionConfigContext as S } from "../../context/MotionConfigContext.js";
import { MotionContext as L } from "../../context/MotionContext/index.js";
import { PresenceContext as b } from "../../context/PresenceContext.js";
import { SwitchLayoutGroupContext as k } from "../../context/SwitchLayoutGroupContext.js";
import { isRefObject as H } from "../../utils/is-ref-object.js";
import { useIsomorphicLayoutEffect as R } from "../../utils/use-isomorphic-effect.js";
import { microtask as z } from "../../../../../motion-dom/dist/es/frameloop/microtask.js";
function Q(o, s, e, r, u) {
  var y, w;
  const { visualElement: a } = f(L), m = f(A), n = f(b), p = f(S).reducedMotion, i = l(null);
  r = r || m.renderer, !i.current && r && (i.current = r(o, {
    visualState: s,
    parent: a,
    props: e,
    presenceContext: n,
    blockInitialAnimation: n ? n.initial === !1 : !1,
    reducedMotionConfig: p
  }));
  const t = i.current, x = f(k);
  t && !t.projection && u && (t.type === "html" || t.type === "svg") && O(i.current, e, u, x);
  const C = l(!1);
  j(() => {
    t && C.current && t.update(e, n);
  });
  const c = e[h], d = l(!!c && !((y = window.MotionHandoffIsComplete) != null && y.call(window, c)) && ((w = window.MotionHasOptimisedAnimation) == null ? void 0 : w.call(window, c)));
  return R(() => {
    t && (C.current = !0, window.MotionIsMounted = !0, t.updateFeatures(), z.render(t.render), d.current && t.animationState && t.animationState.animateChanges());
  }), I(() => {
    t && (!d.current && t.animationState && t.animationState.animateChanges(), d.current && (queueMicrotask(() => {
      var M;
      (M = window.MotionHandoffMarkAsComplete) == null || M.call(window, c);
    }), d.current = !1));
  }), t;
}
function O(o, s, e, r) {
  const { layoutId: u, layout: a, drag: m, dragConstraints: n, layoutScroll: p, layoutRoot: i, layoutCrossfade: t } = s;
  o.projection = new e(o.latestValues, s["data-framer-portal-id"] ? void 0 : g(o.parent)), o.projection.setOptions({
    layoutId: u,
    layout: a,
    alwaysMeasureLayout: !!m || n && H(n),
    visualElement: o,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof a == "string" ? a : "both",
    initialPromotionConfig: r,
    crossfade: t,
    layoutScroll: p,
    layoutRoot: i
  });
}
function g(o) {
  if (o)
    return o.options.allowProjection !== !1 ? o.projection : g(o.parent);
}
export {
  Q as useVisualElement
};
