import { stepsOrder as o } from "./order.js";
import { createRenderStep as w } from "./render-step.js";
import { MotionGlobalConfig as m } from "../../../../motion-utils/dist/es/global-config.js";
const B = 40;
function S(c, p) {
  let r = !1, a = !0;
  const e = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, u = () => r = !0, n = o.reduce((s, t) => (s[t] = w(u, p ? t : void 0), s), {}), { setup: l, read: f, resolveKeyframes: d, preUpdate: g, update: h, preRender: M, render: R, postRender: x } = n, i = () => {
    const s = m.useManualTiming ? e.timestamp : performance.now();
    r = !1, m.useManualTiming || (e.delta = a ? 1e3 / 60 : Math.max(Math.min(s - e.timestamp, B), 1)), e.timestamp = s, e.isProcessing = !0, l.process(e), f.process(e), d.process(e), g.process(e), h.process(e), M.process(e), R.process(e), x.process(e), e.isProcessing = !1, r && p && (a = !1, c(i));
  }, P = () => {
    r = !0, a = !0, e.isProcessing || c(i);
  };
  return { schedule: o.reduce((s, t) => {
    const E = n[t];
    return s[t] = (F, T = !1, b = !1) => (r || P(), E.schedule(F, T, b)), s;
  }, {}), cancel: (s) => {
    for (let t = 0; t < o.length; t++)
      n[o[t]].cancel(s);
  }, state: e, steps: n };
}
export {
  S as createRenderBatcher
};
