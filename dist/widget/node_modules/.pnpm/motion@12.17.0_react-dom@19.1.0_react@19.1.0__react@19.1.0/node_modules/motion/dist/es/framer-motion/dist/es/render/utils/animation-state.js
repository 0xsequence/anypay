import { animateVisualElement as q } from "../../animation/interfaces/visual-element.js";
import { isAnimationControls as G } from "../../animation/utils/is-animation-controls.js";
import { isKeyframesTarget as D } from "../../animation/utils/is-keyframes-target.js";
import { shallowCompare as B } from "../../utils/shallow-compare.js";
import { getVariantContext as J } from "./get-variant-context.js";
import { isVariantLabel as N } from "./is-variant-label.js";
import { resolveVariant as L } from "./resolve-dynamic-variants.js";
import { variantPriorityOrder as F } from "./variant-props.js";
const Q = [...F].reverse(), U = F.length;
function W(e) {
  return (f) => Promise.all(f.map(({ animation: c, options: p }) => q(e, c, p)));
}
function ae(e) {
  let f = W(e), c = k(), p = !0;
  const H = (s) => (t, h) => {
    var o;
    const l = L(e, h, s === "exit" ? (o = e.presenceContext) == null ? void 0 : o.custom : void 0);
    if (l) {
      const { transition: d, transitionEnd: g, ...v } = l;
      t = { ...t, ...v, ...g };
    }
    return t;
  };
  function M(s) {
    f = s(e);
  }
  function K(s) {
    const { props: t } = e, h = J(e.parent) || {}, l = [], o = /* @__PURE__ */ new Set();
    let d = {}, g = 1 / 0;
    for (let u = 0; u < U; u++) {
      const n = Q[u], r = c[n], a = t[n] !== void 0 ? t[n] : h[n], w = N(a), P = n === s ? r.isActive : null;
      P === !1 && (g = u);
      let V = a === h[n] && a !== t[n] && w;
      if (V && p && e.manuallyAnimateOnMount && (V = !1), r.protectedKeys = { ...d }, // If it isn't active and hasn't *just* been set as inactive
      !r.isActive && P === null || // If we didn't and don't have any defined prop for this animation type
      !a && !r.prevProp || // Or if the prop doesn't define an animation
      G(a) || typeof a == "boolean")
        continue;
      const b = X(r.prevProp, a);
      let C = b || // If we're making this variant active, we want to always make it active
      n === s && r.isActive && !V && w || // If we removed a higher-priority variant (i is in reverse order)
      u > g && w, I = !1;
      const R = Array.isArray(a) ? a : [a];
      let y = R.reduce(H(n), {});
      P === !1 && (y = {});
      const { prevResolvedValues: x = {} } = r, j = {
        ...x,
        ...y
      }, O = (i) => {
        C = !0, o.has(i) && (I = !0, o.delete(i)), r.needsAnimating[i] = !0;
        const m = e.getValue(i);
        m && (m.liveStyle = !1);
      };
      for (const i in j) {
        const m = y[i], S = x[i];
        if (d.hasOwnProperty(i))
          continue;
        let T = !1;
        D(m) && D(S) ? T = !B(m, S) : T = m !== S, T ? m != null ? O(i) : o.add(i) : m !== void 0 && o.has(i) ? O(i) : r.protectedKeys[i] = !0;
      }
      r.prevProp = a, r.prevResolvedValues = y, r.isActive && (d = { ...d, ...y }), p && e.blockInitialAnimation && (C = !1), C && (!(V && b) || I) && l.push(...R.map((i) => ({
        animation: i,
        options: { type: n }
      })));
    }
    if (o.size) {
      const u = {};
      if (typeof t.initial != "boolean") {
        const n = L(e, Array.isArray(t.initial) ? t.initial[0] : t.initial);
        n && n.transition && (u.transition = n.transition);
      }
      o.forEach((n) => {
        const r = e.getBaseTarget(n), a = e.getValue(n);
        a && (a.liveStyle = !0), u[n] = r ?? null;
      }), l.push({ animation: u });
    }
    let v = !!l.length;
    return p && (t.initial === !1 || t.initial === t.animate) && !e.manuallyAnimateOnMount && (v = !1), p = !1, v ? f(l) : Promise.resolve();
  }
  function z(s, t) {
    var l;
    if (c[s].isActive === t)
      return Promise.resolve();
    (l = e.variantChildren) == null || l.forEach((o) => {
      var d;
      return (d = o.animationState) == null ? void 0 : d.setActive(s, t);
    }), c[s].isActive = t;
    const h = K(s);
    for (const o in c)
      c[o].protectedKeys = {};
    return h;
  }
  return {
    animateChanges: K,
    setActive: z,
    setAnimateFunction: M,
    getState: () => c,
    reset: () => {
      c = k(), p = !0;
    }
  };
}
function X(e, f) {
  return typeof f == "string" ? f !== e : Array.isArray(f) ? !B(f, e) : !1;
}
function A(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function k() {
  return {
    animate: A(!0),
    whileInView: A(),
    whileHover: A(),
    whileTap: A(),
    whileDrag: A(),
    whileFocus: A(),
    exit: A()
  };
}
export {
  X as checkVariantsDidChange,
  ae as createAnimationState
};
